# 课后习题

### 一、地址栏输入一个url开始, 浏览器都做了什么工作?

1. URL解析
首先判断你输入的是一个合法的URL 还是一个待搜索的关键词，并且根据你输入的内容进行对应操作

2. DNS查询

具体流程查看 - assets/question-dns.png

3. TCP连接

在确定目标服务器服务器的IP地址后，则经历三次握手建立TCP连接

4. 发送 http 请求

当建立tcp连接之后，就可以在这基础上进行通信，浏览器发送 http 请求到目标服务器

请求的内容包括：

请求行
请求头
请求主体

5. 收到 http 响应请求

当服务器接收到浏览器的请求之后，就会进行逻辑操作，处理完成之后返回一个HTTP响应消息，包括：

状态行
响应头
响应正文

在服务器响应之后，由于现在http默认开始长连接keep-alive，当页面关闭之后，tcp链接则会经过四次挥手完成断开

6. 页面渲染

当浏览器接收到服务器响应的资源后，首先会对资源进行解析：

* 查看响应头的信息，根据不同的指示做对应处理，比如重定向，存储cookie，解压gzip，缓存资源等等
* 查看响应头的 Content-Type的值，根据不同的资源类型采用不同的解析方式
  

关于页面的渲染过程如下：

* 解析HTML，构建 DOM 树
* 解析 CSS ，生成 CSS 规则树
* 合并 DOM 树和 CSS 规则，生成 render 树
* 布局 render 树（ Layout / reflow ），负责各元素尺寸、位置的计算
* 绘制 render 树（ paint ），绘制页面像素信息
* 浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上


### 二、js会阻塞HTML的解析过程吗? 为什么?

当HTML解析器碰到script标签的时候，它会停止HTML文档的解析从而转向JavaScript代码的加载，解析以及执行。

为什么要这样做呢？因为script标签中的JavaScript可能会使用诸如document.write()这样的代码改变文档流（document）的形状，从而使整个DOM树的结构发生根本性的改变。因为这个原因，HTML解析器不得不等JavaScript执行完成之后才能继续对HTML文档流的解析工作。


### 三、什么情况下会触发回流/回流? 浏览器本身有什么优化操作吗?

回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流，如下面情况：

* 添加或删除可见的DOM元素
* 元素的位置发生变化
* 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
* 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代
* 页面一开始渲染的时候（这避免不了）
* 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）
  
还有一些容易被忽略的操作：获取一些特定属性的值

offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight

这些属性有一个共性，就是需要通过即时计算得到。因此浏览器为了获取这些值，也会进行回流

除此还包括getComputedStyle方法，原理是一样的。

**浏览器本身有什么优化操作?**

由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列

当你获取布局信息的操作的时候，会强制队列刷新，包括前面讲到的offsetTop等方法都会返回最新的数据

因此浏览器不得不清空队列，触发回流重绘来返回正确的值


### 四、如何尽量避免回流的出现?

* 如果想设定元素的样式，通过改变元素的 class 类名 (尽可能在 DOM 树的最里层)
* 避免设置多项内联样式
* 应用元素的动画，使用 position 属性的 fixed 值或 absolute 值(如前文示例所提)
* 避免使用 table 布局，table 中每个元素的大小以及内容的改动，都会导致整个 table 的重新计算
* 对于那些复杂的动画，对其设置 position: fixed/absolute，尽可能地使元素脱离文档流，从而减少对其他元素的影响
* 使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘
* 避免使用 CSS 的 JavaScript 表达式
* 需要获取offset等属性的时候, 最好用一个变量缓存起来, 不要每次都去获取
   

### 五、浏览器多进程架构的好处是什么?


1. 容错性

Chrome会为每个tab单独分配一个属于它们的渲染进程（render process）。举个例子，假如你有三个tab，你就会有三个独立的渲染进程。

当其中一个tab的崩溃时，你可以随时关闭这个tab并且其他tab不受到影响。可是如果所有的tab都跑在同一个进程的话，它们就会有连带关系，一个挂全部挂。

2. 安全性和沙盒性

因为操作系统可以提供方法让你限制每个进程拥有的能力，所以浏览器可以让某些进程不具备某些特定的功能。例如，由于tab渲染进程可能会处理来自用户的随机输入，所以Chrome限制了它们对系统文件随机读写的能力。

3. 每个进程可以拥有更多内存

因为每个进程都会分配一块独立的内存空间, 所以理所当然的, 每个进程都会有更多的内存。


### z-index的生效规则

1.  只有定位元素才会生效

z-index 这个属性并不是在所有的元素上都有效果。它仅仅只在定位元素（定义了 position 属性，且属性的值为非 static 值的元素）上有效果

2. 层叠顺序

2.1 background/border —— 形成层叠上下文的元素的背景和边框，也是层叠上下文中的最低等级。
2.2 z-index <0 —— 层叠上下文内有着 负z-index值 的子元素。
2.3 block块级盒 —— 文档流中非行内非定位子元素。
2.4 float浮动盒 —— 非定位浮动元素。
2.5 inline/inline-block行内盒 —— 文档流中行内级别非定位子元素。
2.6 z-index: 0 —— 定位元素，这些元素将形成了新的层叠上下文。
2.7 z-index > 0 —— 定位元素。 层叠上下文中的最高等级。

所有的元素层级是按照上面的排序进行的, 也就是说z-index > 0的层级最高, 最靠近屏幕前的我们, 也就是观察者.


3. 同级比较

有的时候我们发现z-index9999 居然比 z-index 100更低? 为什么??

这时候我们要知道z-index是同级比较, 比如下面的例子

div1 z-index:10
    div2 z-index:200
    div3 z-index:999
div4 z-index:20

展示的层级高度是怎样的顺序? 

是div4 > div3 > div2 > div1

因为div1 和 div4是同级的, div4比整体的div1高.

完整的写一下高度, 效果类似于：

div1: 10
div2: 10-200
div3: 10-999
div4: 20